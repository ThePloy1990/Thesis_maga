import os
import time
from datetime import datetime, timedelta, timezone
from pathlib import Path
import shutil

import pytest

from src.market_snapshot.model import MarketSnapshot, SnapshotMeta
from src.market_snapshot.registry import SnapshotRegistry

# Configuration for tests
TEST_S3_STUB_PATH = "local_test/snapshots"


@pytest.fixture(scope="function")
def registry() -> SnapshotRegistry:
    """Provides a SnapshotRegistry instance for testing, cleaning up afterwards."""
    # Ensure the test directory is clean before each test
    if Path(TEST_S3_STUB_PATH).exists():
        shutil.rmtree(TEST_S3_STUB_PATH)
    Path(TEST_S3_STUB_PATH).mkdir(parents=True, exist_ok=True)

    reg = SnapshotRegistry(s3_stub_path=TEST_S3_STUB_PATH)
    # Clear any potential Redis keys from previous runs (use with caution on shared Redis)
    # For CI/local tests, this is generally fine if db= is specific or Redis is test-only.
    reg.delete_all_snapshots_dangerously() # Clears Redis and S3 stub
    yield reg
    # Clean up S3 stub directory after tests
    if Path(TEST_S3_STUB_PATH).exists():
        shutil.rmtree(TEST_S3_STUB_PATH)
    # It's good practice to also clean up Redis keys created by tests if possible,
    # but delete_all_snapshots_dangerously already handles this based on its prefix.


@pytest.fixture
def sample_meta() -> SnapshotMeta:
    """Provides a sample SnapshotMeta instance."""
    return SnapshotMeta(
        id="", # ID will be generated by registry or can be set manually for tests
        created_at=datetime.now(timezone.utc),
        horizon_days=30,
        asset_universe=["AAPL", "MSFT"]
    )


@pytest.fixture
def sample_snapshot(sample_meta: SnapshotMeta) -> MarketSnapshot:
    """Provides a sample MarketSnapshot instance."""
    return MarketSnapshot(
        meta=sample_meta,
        mu={"AAPL": 0.01, "MSFT": 0.02},
        sigma={"AAPL": {"AAPL": 0.005, "MSFT": 0.002}, "MSFT": {"AAPL": 0.002, "MSFT": 0.008}},
        sentiment={"AAPL": 0.5, "MSFT": -0.2},
        raw_features_path="/path/to/features.csv"
    )


def test_save_load(registry: SnapshotRegistry, sample_snapshot: MarketSnapshot):
    """Test saving and loading a snapshot."""
    # Ensure ID is not set, so registry generates it
    sample_snapshot.meta.id = ""
    sample_snapshot.meta.created_at = datetime.now(timezone.utc) # Ensure fresh timestamp

    snapshot_id = registry.save(sample_snapshot)
    assert snapshot_id is not None
    assert len(snapshot_id) > 0

    loaded_snapshot = registry.load(snapshot_id)
    assert loaded_snapshot is not None
    assert loaded_snapshot.meta.id == snapshot_id
    assert loaded_snapshot.mu == sample_snapshot.mu
    assert loaded_snapshot.sigma == sample_snapshot.sigma
    assert loaded_snapshot.sentiment == sample_snapshot.sentiment
    assert loaded_snapshot.raw_features_path == sample_snapshot.raw_features_path
    assert loaded_snapshot.meta.horizon_days == sample_snapshot.meta.horizon_days
    assert loaded_snapshot.meta.asset_universe == sample_snapshot.meta.asset_universe
    # Compare datetimes carefully, considering potential precision differences if any
    assert abs(loaded_snapshot.meta.created_at - sample_snapshot.meta.created_at) < timedelta(seconds=1)

    # Test that S3 stub file was created
    expected_s3_file = Path(TEST_S3_STUB_PATH) / f"{snapshot_id}.json"
    assert expected_s3_file.exists()


def test_load_non_existent(registry: SnapshotRegistry):
    """Test loading a non-existent snapshot."""
    loaded_snapshot = registry.load("non_existent_id_12345")
    assert loaded_snapshot is None


def test_latest_snapshot(registry: SnapshotRegistry, sample_snapshot: MarketSnapshot):
    """Test retrieving the latest snapshot."""
    # Snapshot 1 (older)
    meta1 = SnapshotMeta(
        id="", # Will be auto-generated
        created_at=datetime.now(timezone.utc) - timedelta(hours=2),
        horizon_days=10,
        asset_universe=["GOOG"]
    )
    snap1 = MarketSnapshot(meta=meta1, mu={}, sigma={}, sentiment={}, raw_features_path="path1")
    id1 = registry.save(snap1)
    time.sleep(0.01) # Ensure different creation times for IDs if resolution is too low

    # Snapshot 2 (more recent)
    meta2 = SnapshotMeta(
        id="",
        created_at=datetime.now(timezone.utc) - timedelta(hours=1),
        horizon_days=20,
        asset_universe=["TSLA"]
    )
    snap2 = MarketSnapshot(meta=meta2, mu={}, sigma={}, sentiment={}, raw_features_path="path2")
    id2 = registry.save(snap2)
    time.sleep(0.01)

    # Snapshot 3 (latest)
    meta3 = SnapshotMeta(
        id="",
        created_at=datetime.now(timezone.utc),
        horizon_days=30,
        asset_universe=["BTC"]
    )
    snap3 = MarketSnapshot(meta=meta3, mu={}, sigma={}, sentiment={}, raw_features_path="path3")
    id3 = registry.save(snap3)

    latest_snap = registry.latest()
    assert latest_snap is not None
    assert latest_snap.meta.id == id3
    assert latest_snap.meta.asset_universe == ["BTC"]


def test_latest_snapshot_with_before_timestamp(registry: SnapshotRegistry):
    """Test retrieving the latest snapshot before a given timestamp."""
    now = datetime.now(timezone.utc)

    # Snapshots with explicit IDs and created_at for precise control
    # We are relying on the `created_at` field for the `before` logic.
    # The auto-generated ID format also helps, but `created_at` is the source of truth.

    meta1_time = now - timedelta(minutes=30)
    snap1_id = meta1_time.strftime("%Y-%m-%dT%H-%M-%S.%f") + "Z_test1"
    meta1 = SnapshotMeta(id=snap1_id, created_at=meta1_time, horizon_days=10, asset_universe=["ETH"])
    snap1 = MarketSnapshot(meta=meta1, mu={}, sigma={}, sentiment={}, raw_features_path="path_eth")
    registry.save(snap1)

    meta2_time = now - timedelta(minutes=15)
    snap2_id = meta2_time.strftime("%Y-%m-%dT%H-%M-%S.%f") + "Z_test2"
    meta2 = SnapshotMeta(id=snap2_id, created_at=meta2_time, horizon_days=20, asset_universe=["SOL"])
    snap2 = MarketSnapshot(meta=meta2, mu={}, sigma={}, sentiment={}, raw_features_path="path_sol")
    registry.save(snap2)

    meta3_time = now - timedelta(minutes=1)
    snap3_id = meta3_time.strftime("%Y-%m-%dT%H-%M-%S.%f") + "Z_test3"
    meta3 = SnapshotMeta(id=snap3_id, created_at=meta3_time, horizon_days=30, asset_universe=["ADA"])
    snap3 = MarketSnapshot(meta=meta3, mu={}, sigma={}, sentiment={}, raw_features_path="path_ada")
    registry.save(snap3)

    # Test case 1: before is after all snapshots
    latest_before_future = registry.latest(before=now + timedelta(minutes=10))
    assert latest_before_future is not None
    assert latest_before_future.meta.id == snap3_id # Should be snap3

    # Test case 2: before is between snap2 and snap3
    before_snap3_time = now - timedelta(minutes=5) # This is after snap2, before snap3
    latest_before_snap3 = registry.latest(before=before_snap3_time)
    assert latest_before_snap3 is not None
    assert latest_before_snap3.meta.id == snap2_id # Should be snap2

    # Test case 3: before is between snap1 and snap2
    before_snap2_time = now - timedelta(minutes=20) # This is after snap1, before snap2
    latest_before_snap2 = registry.latest(before=before_snap2_time)
    assert latest_before_snap2 is not None
    assert latest_before_snap2.meta.id == snap1_id # Should be snap1

    # Test case 4: before is before all snapshots
    before_all_time = now - timedelta(hours=1)
    latest_before_all = registry.latest(before=before_all_time)
    assert latest_before_all is None

    # Test case 5: No snapshots exist
    registry.delete_all_snapshots_dangerously()
    assert registry.latest() is None
    assert registry.latest(before=now) is None

def test_s3_stub_persistence(registry: SnapshotRegistry, sample_snapshot: MarketSnapshot):
    """Test that snapshot persists in S3 stub and can be loaded after clearing Redis."""
    sample_snapshot.meta.id = "persist_test_id_001"
    sample_snapshot.meta.created_at = datetime.now(timezone.utc)
    snapshot_id = registry.save(sample_snapshot)

    # Simulate clearing Redis (or Redis cache miss)
    registry.redis_client.delete(f"{registry._snapshot_key_prefix}{snapshot_id}")

    # Load again, should come from S3 stub
    loaded_snapshot = registry.load(snapshot_id)
    assert loaded_snapshot is not None
    assert loaded_snapshot.meta.id == snapshot_id
    assert loaded_snapshot.mu == sample_snapshot.mu

    # Check that the file actually exists
    s3_file_path = registry.s3_stub_path / f"{snapshot_id}.json"
    assert s3_file_path.exists()

    # Verify content by reloading from a new registry instance pointing to the same S3 path
    new_registry = SnapshotRegistry(s3_stub_path=TEST_S3_STUB_PATH)
    # Clear its Redis to ensure it doesn't accidentally load from there
    new_registry.redis_client.delete(f"{new_registry._snapshot_key_prefix}{snapshot_id}")

    reloaded_snapshot = new_registry.load(snapshot_id)
    assert reloaded_snapshot is not None
    assert reloaded_snapshot.meta.id == snapshot_id


def test_id_generation_if_empty(registry: SnapshotRegistry, sample_snapshot: MarketSnapshot):
    """Test that a new ID is generated if snapshot.meta.id is empty/None."""
    sample_snapshot.meta.id = "" # Explicitly set to empty
    sample_snapshot.meta.created_at = datetime.now(timezone.utc)
    generated_id = registry.save(sample_snapshot)
    assert generated_id is not None
    assert len(generated_id) > 0

    loaded_snap = registry.load(generated_id)
    assert loaded_snap is not None
    assert loaded_snap.meta.id == generated_id

    # Test with pre-set ID
    pre_set_id = "my-custom-id-123"
    sample_snapshot.meta.id = pre_set_id
    saved_id_custom = registry.save(sample_snapshot)
    assert saved_id_custom == pre_set_id

    loaded_custom_snap = registry.load(pre_set_id)
    assert loaded_custom_snap is not None
    assert loaded_custom_snap.meta.id == pre_set_id
